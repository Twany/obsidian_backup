## 时间轮算法
### **时间轮概述**
时间轮是一种高效来利用线程资源来进行批量化调度的一种调度模型。把大批量的调度任务全部都绑定到同一个的调度器上面，使用这一个调度器来进行所有任务的管理（manager），触发（trigger）以及运行（runnable）。能够高效的管理各种延时任务，周期任务，通知任务等等。
不过，时间轮调度器的时间精度可能不是很高，对于精度要求特别高的调度任务可能不太适合。因为时间轮算法的精度取决于，时间段“指针”单元的最小粒度大小，比如时间轮的格子是一秒跳一次，那么调度精度小于一秒的任务就无法被时间轮所调度。
优点也是很明显的：
- 任务添加删除都是O(1)
- 只要有一个线程推进时间轮即可
- 不会占用大量资源，只需要一个外部数组（时间轮整体就是一个数组结构），数组的每个元素可以是数组或者链表
	- 当然如果对于时间经精度要求高的话，就要费空间了，如纳米级别 就需要一个特大的数组了
![[image-20230712100050340.png|700]]

> Kfaka就是用的时间轮，Netty也是

### 时间轮算法的原理
![](https://pic2.zhimg.com/v2-706ced1f9604afd780d6fb4a63de2e25_b.jpg)

个人理解，就是划分一个时间段，然后将需要在该时间段执行的任务放在该段对应的队列中；当指针移动到该位置就把该队列中符合条件的任务给执行了。

例如：当前时间18:00，你有一个任务是19:00执行。你只需要将你的任务挂在19:00这个位置就行，当我们的钟表到19:00后，就会有一个工作线程处理你的任务。

**任务的执行原理：**

时间轮算法可以通过上图来描述。假设时间轮大小为10，1s转一格，每格指向一个链表，保存着待执行的任务。
假设，当前位于1，现在要添加一个3s后指向的任务，则1+3=4，在第4格的链表中添加一个节点指向任务即可，标识round=0（round表示圈数）。
假设，当前位于1，现在要添加一个10s后指向的任务，则（1+10）% 10 = 1，则在第1格添加一个节点指向任务，并标识round=1（round表示圈数），则当时间轮第二次经过第1格时，即会执行任务。
时间轮只会执行round=0的任务，并会把该格子上的其他任务的round减1。

**为什么时间段是一个圆形？**
之所以使用环形的数据结构，主要是处理时间跨度很大的问题。假如我们1s是一个时间段，一天24小时，我们需要划分24*60*60=86400个区间，如果是1个月呢。显然环形结构可以很优雅的处理该问题。
我们认为这是一个周期为12秒的圆形，每个数字间隔是1s。我们要表示60s就是60/12=5。也就是指针从12开始转5圈。由此可见，一个圆形可以处理任何时间跨度。

**Netty中的使用**

![](https://pic4.zhimg.com/v2-33090701f753d8eff5a6f167cf469edf_b.jpg)
